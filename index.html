<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>FPS Gameplay Review Tool</title>
  <!-- Meta Tags for Responsive Design -->
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css">
  <!-- Bootstrap Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
  <!-- Custom Styles -->
  <style>
    /* [Your existing CSS styles] */
    /* General Styles */
    body {
      overflow-x: hidden;
    }

    /* Video Container */
    #video-container {
      position: relative;
      width: 100%;
      max-width: 640px;
      margin: 0 auto;
    }

    /* Video Overlay */
    #video-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    /* Video Comment Overlay */
    .video-comment {
      position: absolute;
      bottom: 10%;
      left: 5%;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 10px;
      border-radius: 5px;
      max-width: 90%;
      animation: fadeInOut 5s ease-in-out;
    }

    @keyframes fadeInOut {
      0% { opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { opacity: 0; }
    }

    /* Timeline */
    #timeline-container {
      position: relative;
      width: 100%;
      max-width: 640px;
      height: 20px;
      background-color: #333;
      margin: 10px auto;
    }

    #timeline {
      position: relative;
      width: 100%;
      height: 100%;
    }

    .timeline-marker {
      position: absolute;
      width: 4px;
      height: 100%;
      background-color: #f1c40f;
      cursor: pointer;
    }

    /* Comment Feed */
    #comment-feed {
      max-height: 500px;
      overflow-y: auto;
    }

    .comment-item {
      position: relative;
      padding-left: 50px;
    }

    .comment-emoji {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 24px;
    }

    .comment-delete {
      position: absolute;
      top: 10px;
      right: 10px;
      cursor: pointer;
      color: #dc3545;
    }

    .comment-item.active {
      background-color: #f1c40f;
    }

    /* Sentiment Shading */
    .sentiment-good {
      background-color: #e0f8e0; /* Light green */
    }

    .sentiment-warning {
      background-color: #fff8e0; /* Light yellow */
    }

    .sentiment-bad {
      background-color: #f8e0e0; /* Light red */
    }

    /* Video Thumbnail */
    .video-thumbnail {
      width: 100px;
      height: 75px;
      object-fit: cover;
    }

    /* Video List in Sidebar */
    #video-list {
      list-style-type: none;
      padding-left: 0;
    }

    #video-list li {
      margin-bottom: 10px;
      cursor: pointer;
    }

    #video-list li.active {
      background-color: #e9ecef;
    }

    /* Adjust content when sidebar is visible */
    @media (min-width: 992px) {
      #content {
        margin-left: 250px;
      }
    }
  </style>
</head>
<body>
  <!-- Toolbar -->
  <nav class="navbar navbar-dark bg-dark px-3">
    <div class="container-fluid">
      <button type="button" id="sidebarCollapse" class="btn btn-dark me-2" aria-label="Toggle sidebar" data-bs-toggle="offcanvas" data-bs-target="#sidebar">
        <i class="bi bi-list"></i>
      </button>
      <h5 class="navbar-brand mb-0">FPS Gameplay Review Tool</h5>
      <div class="d-flex">
        <button class="btn btn-outline-light me-2" id="load-video-btn">
          <i class="bi bi-film"></i> Load New Video
        </button>
        <button class="btn btn-outline-light me-2" id="import-comments-btn">
          <i class="bi bi-cloud-arrow-down-fill"></i> Import Comments
        </button>
        <button class="btn btn-outline-light me-2" id="help-btn">
          <i class="bi bi-question-circle-fill"></i> Help
        </button>
      </div>
    </div>
  </nav>

  <!-- Sidebar -->
  <div class="offcanvas offcanvas-start" tabindex="-1" id="sidebar" aria-labelledby="sidebarLabel">
    <div class="offcanvas-header">
      <h5 class="offcanvas-title" id="sidebarLabel"><i class="bi bi-gear-fill"></i> Settings</h5>
      <button type="button" class="btn-close text-reset" data-bs-dismiss="offcanvas" aria-label="Close"></button>
    </div>
    <div class="offcanvas-body">
      <!-- Author Name Input -->
      <div class="mb-3">
        <label for="author-name" class="form-label">Author Name</label>
        <input type="text" id="author-name" class="form-control" placeholder="Enter your name">
      </div>
      <!-- Video List -->
      <h6>Loaded Videos</h6>
      <ul id="video-list">
        <!-- Videos will be dynamically added here -->
      </ul>
      <hr>
      <h6>Settings</h6>
      <ul class="components list-unstyled">
        <li>
          <div class="form-check form-switch ms-2">
            <input class="form-check-input" type="checkbox" id="audio-notifications">
            <label class="form-check-label" for="audio-notifications">Enable Sound Notifications</label>
          </div>
        </li>
        <li class="ms-2">
          <label for="audio-volume">Notification Volume</label>
          <input type="range" id="audio-volume" class="form-range" min="0" max="1" step="0.1" value="0.5">
        </li>
        <li class="ms-2">
          <label>Comment Display Options</label>
          <div class="form-check">
            <input class="form-check-input" type="radio" name="comment-display" id="show-all-comments" checked>
            <label class="form-check-label" for="show-all-comments">
              Show All Comments
            </label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="radio" name="comment-display" id="show-up-to-current-time">
            <label class="form-check-label" for="show-up-to-current-time">
              Show Comments Up to Current Time
            </label>
          </div>
        </li>
      </ul>
    </div>
  </div>

  <!-- Page Content -->
  <div id="content">
    <div class="container-fluid">
      <div class="row mt-4">
        <!-- Video and Timeline Column -->
        <div class="col-lg-8 col-md-12">
          <!-- Video Container -->
          <div id="video-container" class="card shadow-sm mb-3">
            <iframe id="video-player" width="640" height="390" src="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            <div id="video-overlay"></div>
          </div>
          <!-- Timeline -->
          <div id="timeline-container" class="mb-3">
            <div id="timeline"></div>
          </div>
          <!-- Controls -->
          <div class="mb-3 text-center">
            <button id="add-comment" class="btn btn-primary me-2" aria-label="Add Comment" data-bs-toggle="modal" data-bs-target="#commentModal">
              <i class="bi bi-plus-circle"></i> Add Comment
            </button>
            <div class="btn-group" role="group" aria-label="Comment navigation">
              <button id="prev-comment" class="btn btn-secondary" aria-label="Previous Comment" data-bs-toggle="tooltip" title="Previous Comment">
                <i class="bi bi-skip-backward-fill"></i>
              </button>
              <button id="next-comment" class="btn btn-secondary" aria-label="Next Comment" data-bs-toggle="tooltip" title="Next Comment">
                <i class="bi bi-skip-forward-fill"></i>
              </button>
            </div>
            <button id="export-comments" class="btn btn-info ms-2" aria-label="Share Comments">
              <i class="bi bi-share-fill"></i> Share Comments
            </button>
            <button id="export-comments-file" class="btn btn-secondary ms-2" aria-label="Export Comments to File">
              <i class="bi bi-cloud-arrow-up-fill"></i> Export Comments to File
            </button>
          </div>
        </div>
        <!-- Comments Column -->
        <div class="col-lg-4 col-md-12">
          <!-- Comment Feed -->
          <h4>Comments</h4>
          <div id="comment-feed" class="list-group" aria-label="List of comments">
            <!-- Comments dynamically added here -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Comment Modal -->
  <div class="modal fade" id="commentModal" tabindex="-1" aria-labelledby="commentModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <form id="comment-form">
          <div class="modal-header">
            <h5 class="modal-title" id="commentModalLabel">Add Comment</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
              <div class="mb-3">
                <label for="comment-text" class="form-label">Comment</label>
                <textarea class="form-control" id="comment-text" rows="3" required></textarea>
              </div>
              <div class="mb-3">
                <label for="comment-sentiment" class="form-label">Sentiment</label>
                <select id="comment-sentiment" class="form-select">
                  <option value="good" selected>Good (Green)</option>
                  <option value="warning">Warning (Yellow)</option>
                  <option value="bad">Bad (Red)</option>
                </select>
              </div>
              <div class="mb-3">
                <label for="comment-category" class="form-label">Category</label>
                <select id="comment-category" class="form-select">
                  <option value="gameplay">Gameplay üéÆ</option>
                  <option value="crosshair">Crosshair Placement üéØ</option>
                  <option value="movement">Movement üèÉ</option>
                </select>
              </div>
              <div class="mb-3">
                <label for="comment-timestamp" class="form-label">Timestamp</label>
                <input type="text" id="comment-timestamp" class="form-control" readonly>
              </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            <button type="submit" class="btn btn-primary" id="save-comment-btn">Save Comment</button>
          </div>
        </form>
      </div>
    </div>
  </div>

  <!-- File Input for Importing Comments -->
  <input type="file" id="import-file-input" accept=".json" style="display: none;">

  <!-- LZ-String Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

  <!-- Custom JavaScript Code -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      'use strict';

      let playerReady = false;
      let player;
      let currentVideoId = null;
      let commentsData = {}; // { videoId: { authorName: [comments] } }

      // Load data from localStorage
      let loadedVideos = JSON.parse(localStorage.getItem('loadedVideos')) || [];
      commentsData = JSON.parse(localStorage.getItem('commentsData')) || {};

      // Initialize video list
      function updateVideoList() {
        const videoListElement = document.getElementById('video-list');
        if (!videoListElement) {
          console.error('Element with ID "video-list" not found.');
          return;
        }
        videoListElement.innerHTML = '';
        loadedVideos.forEach(video => {
          const li = document.createElement('li');
          li.classList.add('d-flex', 'align-items-center');
          li.dataset.videoId = video.id;
          li.innerHTML = `
            <img src="${video.thumbnail}" alt="Thumbnail" class="video-thumbnail me-2">
            <span>${video.title}</span>
          `;
          li.addEventListener('click', function() {
            loadVideoById(video.id);
            // Close the sidebar
            const sidebar = bootstrap.Offcanvas.getInstance(document.getElementById('sidebar'));
            if (sidebar) sidebar.hide();
          });
          videoListElement.appendChild(li);
        });
      }
      updateVideoList();

      // Parse URL fragment for shared data
      parseSharedDataFromURL();

      // Load New Video Button
      const loadVideoButton = document.getElementById('load-video-btn');
      loadVideoButton.addEventListener('click', function() {
        const videoInput = prompt('Enter YouTube Video ID or URL:');
        if (videoInput) {
          const videoId = extractVideoId(videoInput);
          if (videoId) {
            fetchVideoDetails(videoId).then(videoDetails => {
              // Check if video is already loaded
              if (!loadedVideos.some(video => video.id === videoId)) {
                loadedVideos.push(videoDetails);
                localStorage.setItem('loadedVideos', JSON.stringify(loadedVideos));
                updateVideoList();
              }
              loadVideoById(videoId);
            }).catch(error => {
              alert('Failed to load video details. Please check the video ID or URL.');
            });
          } else {
            alert('Invalid YouTube Video ID or URL.');
          }
        }
      });

      function extractVideoId(input) {
        const regex = /(?:\?v=|\/embed\/|\.be\/|\/v\/|\/watch\?v=|youtu\.be\/)([^&\n?#]+)/;
        const match = input.match(regex);
        return match ? match[1] : input;
      }

      function fetchVideoDetails(videoId) {
        return new Promise((resolve, reject) => {
          fetch(`https://noembed.com/embed?url=https://www.youtube.com/watch?v=${videoId}`)
            .then(response => response.json())
            .then(data => {
              if (data.error) {
                reject(data.error);
              } else {
                const videoDetails = {
                  id: videoId,
                  title: data.title,
                  thumbnail: data.thumbnail_url
                };
                resolve(videoDetails);
              }
            }).catch(error => {
              reject(error);
            });
        });
      }

      function loadVideoById(videoId) {
        currentVideoId = videoId;
        const iframe = document.getElementById('video-player');
        iframe.src = `https://www.youtube.com/embed/${videoId}?enablejsapi=1`;
        initPlayer();
        updateActiveVideoInList(videoId);
      }

      function updateActiveVideoInList(videoId) {
        const videoListElement = document.getElementById('video-list');
        const videoItems = videoListElement.querySelectorAll('li');
        videoItems.forEach(item => {
          if (item.dataset.videoId === videoId) {
            item.classList.add('active');
          } else {
            item.classList.remove('active');
          }
        });
      }

      function initPlayer() {
        if (typeof YT !== 'undefined' && YT && YT.Player) {
          player = new YT.Player('video-player', {
            events: {
              'onReady': onPlayerReady,
              'onStateChange': onPlayerStateChange
            }
          });
        } else {
          // Load the YouTube API script dynamically
          var tag = document.createElement('script');
          tag.src = "https://www.youtube.com/iframe_api";
          var firstScriptTag = document.getElementsByTagName('script')[0];
          firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
          window.onYouTubeIframeAPIReady = function() {
            player = new YT.Player('video-player', {
              events: {
                'onReady': onPlayerReady,
                'onStateChange': onPlayerStateChange
              }
            });
          };
        }
      }

      function onPlayerReady(event) {
        playerReady = true;
        // Load comments for the current video
        if (currentVideoId) {
          loadCommentsForVideo(currentVideoId);
        }
      }

      function onPlayerStateChange(event) {
        // Handle player state changes if needed
      }

      // Parse shared data from URL fragment
      function parseSharedDataFromURL() {
        const hash = window.location.hash.substring(1);
        if (hash) {
          try {
            const decodedData = LZString.decompressFromEncodedURIComponent(hash);
            if (decodedData) {
              const sharedData = JSON.parse(decodedData);
              const videoId = sharedData.videoId;
              const authorName = sharedData.author;
              const importedComments = sharedData.comments;

              // Add video to loadedVideos if not already present
              if (!loadedVideos.some(video => video.id === videoId)) {
                fetchVideoDetails(videoId).then(videoDetails => {
                  loadedVideos.push(videoDetails);
                  localStorage.setItem('loadedVideos', JSON.stringify(loadedVideos));
                  updateVideoList();
                  // Replace comments from the same author
                  replaceComments(sharedData);
                  loadVideoById(videoId);
                }).catch(error => {
                  alert('Failed to load video details from shared URL.');
                });
              } else {
                // Replace comments from the same author
                replaceComments(sharedData);
                loadVideoById(videoId);
              }

              // Clear the URL fragment after processing
              history.replaceState(null, '', window.location.pathname);
            }
          } catch (error) {
            console.error('Error parsing shared data from URL:', error);
          }
        }
      }

      // Save Comment Button in Modal
      const saveCommentButton = document.getElementById('save-comment-btn');
      saveCommentButton.addEventListener('click', function(event) {
        event.preventDefault();
        if (!currentVideoId) {
          alert('No video loaded.');
          return;
        }

        const authorNameInput = document.getElementById('author-name');
        const authorName = authorNameInput.value.trim() || 'Anonymous';

        const commentText = document.getElementById('comment-text').value;
        const commentSentiment = document.getElementById('comment-sentiment').value;
        const commentCategory = document.getElementById('comment-category').value;
        const commentTimestamp = document.getElementById('comment-timestamp').value;

        // Create comment object
        const comment = {
          text: commentText,
          sentiment: commentSentiment,
          category: commentCategory,
          timestamp: commentTimestamp,
          author: authorName
        };

        // Save comment to commentsData
        if (!commentsData[currentVideoId]) {
          commentsData[currentVideoId] = {};
        }
        if (!commentsData[currentVideoId][authorName]) {
          commentsData[currentVideoId][authorName] = [];
        }
        commentsData[currentVideoId][authorName].push(comment);
        localStorage.setItem('commentsData', JSON.stringify(commentsData));

        // Add comment to UI
        addCommentToFeed(comment);

        // Add marker to timeline
        addTimelineMarker(comment.timestamp);

        const commentModal = bootstrap.Modal.getInstance(document.getElementById('commentModal'));
        commentModal.hide();
        document.getElementById('comment-form').reset();
      });

      function addCommentToFeed(comment) {
        const commentFeed = document.getElementById('comment-feed');

        // Create comment card
        const commentItem = document.createElement('div');
        commentItem.classList.add('list-group-item', 'comment-item', `sentiment-${comment.sentiment}`);

        // Get emoji based on category
        const categoryEmojis = {
          'gameplay': 'üéÆ',
          'crosshair': 'üéØ',
          'movement': 'üèÉ'
        };
        const emoji = categoryEmojis[comment.category] || '';

        commentItem.innerHTML = `
          <div class="comment-emoji">${emoji}</div>
          <div class="comment-delete" title="Delete Comment">&times;</div>
          <div style="margin-left: 0;">
            <strong>${capitalizeFirstLetter(comment.category)}</strong> [${comment.timestamp}]<br>
            <em>By ${comment.author}</em><br>
            ${comment.text}
          </div>
        `;

        // Delete comment functionality
        const deleteButton = commentItem.querySelector('.comment-delete');
        deleteButton.addEventListener('click', function(e) {
          e.stopPropagation(); // Prevent triggering the comment click event
          if (confirm('Are you sure you want to delete this comment?')) {
            deleteComment(comment);
            commentItem.remove();
            // Update localStorage
            localStorage.setItem('commentsData', JSON.stringify(commentsData));
            // Reload comments and timeline markers
            if (playerReady) {
              loadCommentsForVideo(currentVideoId);
            }
          }
        });

        commentItem.addEventListener('click', function() {
          if (player && playerReady) {
            const timeInSeconds = parseTime(comment.timestamp);
            player.seekTo(timeInSeconds, true);
          }
        });

        commentFeed.appendChild(commentItem);
      }

      function deleteComment(commentToDelete) {
        const authorComments = commentsData[currentVideoId][commentToDelete.author];
        const index = authorComments.findIndex(comment => {
          return comment.text === commentToDelete.text &&
                 comment.timestamp === commentToDelete.timestamp &&
                 comment.category === commentToDelete.category &&
                 comment.sentiment === commentToDelete.sentiment;
        });
        if (index !== -1) {
          authorComments.splice(index, 1);
          // If no comments left for the author, remove the author key
          if (authorComments.length === 0) {
            delete commentsData[currentVideoId][commentToDelete.author];
            // If no authors left for the video, remove the video key
            if (Object.keys(commentsData[currentVideoId]).length === 0) {
              delete commentsData[currentVideoId];
            }
          }
        }
      }

      function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
      }

      function addTimelineMarker(timestamp) {
        const timeInSeconds = parseTime(timestamp);
        if (player && player.getDuration && player.getDuration() > 0) {
          const videoDuration = player.getDuration();
          const timeline = document.getElementById('timeline');
          const markerPosition = (timeInSeconds / videoDuration) * 100;

          const marker = document.createElement('div');
          marker.classList.add('timeline-marker');
          marker.style.left = `${markerPosition}%`;

          marker.addEventListener('click', function() {
            if (player && playerReady) {
              player.seekTo(timeInSeconds, true);
            }
          });

          timeline.appendChild(marker);
        } else {
          // Wait and try again if duration is not yet available
          setTimeout(() => addTimelineMarker(timestamp), 100);
        }
      }

      function loadCommentsForVideo(videoId) {
        const commentFeed = document.getElementById('comment-feed');
        commentFeed.innerHTML = '';
        const timeline = document.getElementById('timeline');
        timeline.innerHTML = '';

        if (commentsData[videoId]) {
          for (let author in commentsData[videoId]) {
            // Ensure that commentsData[videoId][author] is an array
            const authorComments = commentsData[videoId][author];
            if (Array.isArray(authorComments)) {
              authorComments.forEach(comment => {
                addCommentToFeed(comment);
                addTimelineMarker(comment.timestamp);
              });
            } else {
              console.error(`Comments for author ${author} are not an array:`, authorComments);
            }
          }
        }
      }

      // Update Timestamp when Modal Opens
      const commentModalElement = document.getElementById('commentModal');
      commentModalElement.addEventListener('show.bs.modal', function () {
        const commentTimestampInput = document.getElementById('comment-timestamp');
        if (player && typeof player.getCurrentTime === 'function') {
          const currentTime = player.getCurrentTime();
          commentTimestampInput.value = formatTime(currentTime);
        } else {
          alert('Please load a video before adding comments.');
          const commentModal = bootstrap.Modal.getInstance(commentModalElement);
          commentModal.hide();
        }
      });

      function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
      }

      function parseTime(timeString) {
        const parts = timeString.split(':');
        let seconds = 0;
        for (let i = 0; i < parts.length; i++) {
          seconds = seconds * 60 + parseInt(parts[i], 10);
        }
        return seconds;
      }

      // Previous and Next Comment Buttons
      const prevCommentButton = document.getElementById('prev-comment');
      const nextCommentButton = document.getElementById('next-comment');

      prevCommentButton.addEventListener('click', function() {
        navigateComments(-1);
      });

      nextCommentButton.addEventListener('click', function() {
        navigateComments(1);
      });

      function navigateComments(direction) {
        let allComments = [];
        if (commentsData[currentVideoId]) {
          for (let author in commentsData[currentVideoId]) {
            const authorComments = commentsData[currentVideoId][author];
            if (Array.isArray(authorComments)) {
              allComments = allComments.concat(authorComments);
            } else {
              console.error(`Comments for author ${author} are not an array:`, authorComments);
            }
          }
        }

        if (allComments.length === 0 || !playerReady) return;

        const currentTime = player.getCurrentTime();
        const sortedComments = allComments.map(comment => {
          return { comment, time: parseTime(comment.timestamp) };
        }).sort((a, b) => a.time - b.time);

        let targetComment;
        if (direction === 1) {
          // Next comment
          targetComment = sortedComments.find(c => c.time > currentTime);
        } else {
          // Previous comment
          for (let i = sortedComments.length - 1; i >= 0; i--) {
            if (sortedComments[i].time < currentTime) {
              targetComment = sortedComments[i];
              break;
            }
          }
        }

        if (targetComment) {
          player.seekTo(targetComment.time, true);
        }
      }

      // Export Comments Functionality (Generate Shareable URL)
      const exportCommentsButton = document.getElementById('export-comments');
      exportCommentsButton.addEventListener('click', function() {
        if (!currentVideoId) {
          alert('No video loaded.');
          return;
        }

        const authorNameInput = document.getElementById('author-name');
        const authorName = authorNameInput.value.trim() || 'Anonymous';

        if (!commentsData[currentVideoId] || !commentsData[currentVideoId][authorName] || !Array.isArray(commentsData[currentVideoId][authorName]) || commentsData[currentVideoId][authorName].length === 0) {
          alert(`No comments to share for this video by ${authorName}.`);
          return;
        }

        // Prepare data for sharing
        const dataToShare = {
          videoId: currentVideoId,
          author: authorName,
          comments: commentsData[currentVideoId][authorName]
        };
        const dataStr = JSON.stringify(dataToShare);
        const compressedData = LZString.compressToEncodedURIComponent(dataStr);

        // Check URL length
        if (compressedData.length > 1800) {
          alert('Comments data is too large to share via URL. Please use the export/import feature.');
          return;
        }

        // Generate shareable URL
        const baseUrl = window.location.origin + window.location.pathname;
        const shareUrl = `${baseUrl}#${compressedData}`;

        // Copy URL to clipboard and notify user
        copyToClipboard(shareUrl);
        alert('Shareable URL has been copied to your clipboard.');
      });

      function copyToClipboard(text) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        try {
          document.execCommand('copy');
        } catch (err) {
          console.error('Failed to copy text to clipboard:', err);
        }
        document.body.removeChild(textarea);
      }

      // Export Comments to File Functionality
      const exportCommentsFileButton = document.getElementById('export-comments-file');
      exportCommentsFileButton.addEventListener('click', function() {
        if (!currentVideoId) {
          alert('No video loaded.');
          return;
        }

        const authorNameInput = document.getElementById('author-name');
        const authorName = authorNameInput.value.trim() || 'Anonymous';

        if (!commentsData[currentVideoId] || !commentsData[currentVideoId][authorName] || !Array.isArray(commentsData[currentVideoId][authorName]) || commentsData[currentVideoId][authorName].length === 0) {
          alert(`No comments to export for this video by ${authorName}.`);
          return;
        }

        // Prepare data for export
        const dataToExport = {
          videoId: currentVideoId,
          author: authorName,
          comments: commentsData[currentVideoId][authorName]
        };

        const dataStr = JSON.stringify(dataToExport, null, 2); // Pretty print with indentation

        // Create a Blob and trigger a download
        const blob = new Blob([dataStr], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `comments_${currentVideoId}_${authorName}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });

      // Import Comments Functionality
      const importCommentsButton = document.getElementById('import-comments-btn');
      const importFileInput = document.getElementById('import-file-input');

      importCommentsButton.addEventListener('click', function() {
        importFileInput.click();
      });

      importFileInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(e) {
            try {
              const importedData = JSON.parse(e.target.result);
              if (importedData.videoId && importedData.comments && importedData.author) {
                const videoId = importedData.videoId;
                const authorName = importedData.author;

                // Ensure importedComments is an array
                if (!Array.isArray(importedData.comments)) {
                  alert('Invalid comments format in the imported file.');
                  return;
                }

                // Add video to loadedVideos if not already present
                if (!loadedVideos.some(video => video.id === videoId)) {
                  fetchVideoDetails(videoId).then(videoDetails => {
                    loadedVideos.push(videoDetails);
                    localStorage.setItem('loadedVideos', JSON.stringify(loadedVideos));
                    updateVideoList();
                    // Replace comments from the same author
                    replaceComments(importedData);
                    loadVideoById(videoId);
                  }).catch(error => {
                    alert('Failed to load video details. Please check the video ID.');
                  });
                } else {
                  // Replace comments from the same author
                  replaceComments(importedData);
                  loadVideoById(videoId);
                }
              } else {
                alert('Invalid comments file.');
              }
            } catch (error) {
              alert('Error parsing the comments file.');
            }
          };
          reader.readAsText(file);
        }
        // Reset the file input
        importFileInput.value = '';
      });

      function replaceComments(importedData) {
        const videoId = importedData.videoId;
        const importedComments = importedData.comments;
        const authorName = importedData.author;

        // Ensure importedComments is an array
        if (!Array.isArray(importedComments)) {
          console.error('Imported comments are not an array:', importedComments);
          return;
        }

        if (!commentsData[videoId]) {
          commentsData[videoId] = {};
        }
        // Replace existing comments from the same author
        commentsData[videoId][authorName] = importedComments;

        localStorage.setItem('commentsData', JSON.stringify(commentsData));
      }

      // Initialize with the first loaded video if available
      if (loadedVideos.length > 0 && !currentVideoId) {
        loadVideoById(loadedVideos[0].id);
      }

    }); // End of DOMContentLoaded
  </script>
</body>
</html>
